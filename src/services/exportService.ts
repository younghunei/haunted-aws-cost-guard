import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { saveAs } from 'file-saver';
import { 
  preparePDFElement, 
  getOptimizedCanvasOptions, 
  validateElementForPDF,
  sanitizeTextForPDF,
  checkKoreanFontSupport
} from '../utils/pdfUtils';

// Korean font support for PDF
const KOREAN_FONT_FALLBACK = {
  title: 'Haunted AWS Cost Guard Report',
  generated: 'Generated',
  costSummary: 'Cost Summary',
  totalCost: 'Total Cost',
  mode: 'Mode',
  services: 'Services',
  cost: 'Cost',
  budgetUsage: 'Budget Usage',
  generatedBy: 'Generated by Haunted AWS Cost Guard'
};

export interface ExportOptions {
  format: 'pdf' | 'png' | 'json' | 'csv';
  includeVisual: boolean;
  includeData: boolean;
  filename?: string;
}

export interface MansionSnapshot {
  timestamp: Date;
  services: any[];
  viewSettings: {
    zoom: number;
    center: { x: number; y: number };
    showDetails: boolean;
  };
  budgets?: any[];
  metadata: {
    version: string;
    mode: 'demo' | 'aws';
    totalCost: number;
    currency: string;
  };
}

class ExportService {
  /**
   * Prepare element for optimal capture
   */
  private prepareElementForCapture(element: HTMLElement): () => void {
    const originalStyles = new Map<HTMLElement, string>();
    
    // Store original styles and apply capture-friendly styles
    const allElements = element.querySelectorAll('*');
    allElements.forEach((el) => {
      const htmlEl = el as HTMLElement;
      originalStyles.set(htmlEl, htmlEl.style.cssText);
      
      // Optimize for capture
      htmlEl.style.animation = 'none';
      htmlEl.style.transition = 'none';
      htmlEl.style.transform = 'none';
      htmlEl.style.fontFamily = 'Arial, sans-serif';
      htmlEl.style.webkitFontSmoothing = 'antialiased';
      htmlEl.style.textRendering = 'optimizeLegibility';
      
      // Special handling for canvas elements
      if (htmlEl.tagName === 'CANVAS') {
        htmlEl.style.opacity = '1';
        htmlEl.style.visibility = 'visible';
        htmlEl.style.display = 'block';
      }
    });
    
    // Add capture-ready class
    element.classList.add('pdf-export-ready');
    
    // Return restore function
    return () => {
      element.classList.remove('pdf-export-ready');
      originalStyles.forEach((style, el) => {
        el.style.cssText = style;
      });
    };
  }

  /**
   * Enhanced DOM capture PDF export method
   */
  async exportToPDFEnhanced(
    elementId: string,
    filename: string = 'haunted-mansion-report',
    options: { includeData?: boolean; snapshot?: MansionSnapshot } = {}
  ): Promise<void> {
    try {
      console.log('ðŸŽƒ Starting enhanced PDF export...', { elementId, filename });
      
      const element = document.getElementById(elementId);
      if (!element) {
        throw new Error('Element not found');
      }

      // Scroll to top and ensure element is visible
      window.scrollTo(0, 0);
      element.scrollIntoView({ behavior: 'instant', block: 'start' });
      
      // Wait for scroll to complete
      await new Promise(resolve => setTimeout(resolve, 500));

      // Prepare element for capture
      const restoreElement = this.prepareElementForCapture(element);
      
      try {
        // Wait for animations to settle
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Get element dimensions
        const rect = element.getBoundingClientRect();
        const elementWidth = Math.max(element.scrollWidth, element.offsetWidth, rect.width);
        const elementHeight = Math.max(element.scrollHeight, element.offsetHeight, rect.height);
        
        console.log('Element dimensions:', { 
          width: elementWidth, 
          height: elementHeight,
          scrollWidth: element.scrollWidth,
          offsetWidth: element.offsetWidth,
          rectWidth: rect.width
        });

        // Create canvas with proper dimensions
        const canvas = await html2canvas(element, {
          backgroundColor: '#1a1a2e',
          scale: 1.5, // Good balance between quality and performance
          useCORS: true,
          allowTaint: true,
          logging: false,
          width: elementWidth,
          height: elementHeight,
          windowWidth: window.innerWidth,
          windowHeight: window.innerHeight,
          scrollX: 0,
          scrollY: 0,
          foreignObjectRendering: false, // Better compatibility
          imageTimeout: 15000,
          removeContainer: false,
          letterRendering: true, // Better text rendering
          onclone: (clonedDoc, clonedElement) => {
            // Ensure all text is properly rendered in clone
            const allTextElements = clonedElement.querySelectorAll('*');
            allTextElements.forEach((el) => {
              const htmlEl = el as HTMLElement;
              if (htmlEl.style) {
                htmlEl.style.fontFamily = 'Arial, sans-serif';
                htmlEl.style.webkitFontSmoothing = 'antialiased';
                htmlEl.style.textRendering = 'optimizeLegibility';
              }
            });
            
            // Handle canvas elements
            const canvases = clonedElement.querySelectorAll('canvas');
            canvases.forEach((canvas) => {
              canvas.style.opacity = '1';
              canvas.style.visibility = 'visible';
              canvas.style.display = 'block';
            });
          }
        });

        console.log('Canvas created:', { 
          width: canvas.width, 
          height: canvas.height 
        });

        if (canvas.width === 0 || canvas.height === 0) {
          throw new Error('Canvas capture failed - invalid dimensions');
        }

        // Create PDF with proper orientation
        const isLandscape = canvas.width > canvas.height;
        const pdf = new jsPDF({
          orientation: isLandscape ? 'landscape' : 'portrait',
          unit: 'mm',
          format: 'a4'
        });

        // Add title with proper encoding
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(20);
        pdf.setTextColor(255, 107, 53);
        pdf.text('Haunted AWS Cost Guard Report', 20, 20);

        // Add timestamp
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(12);
        pdf.setTextColor(100, 100, 100);
        const timestamp = new Date().toLocaleString('en-US', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit'
        });
        pdf.text(`Generated: ${timestamp}`, 20, 30);

        // Calculate image dimensions to fit page perfectly
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        
        const maxWidth = pageWidth - 40; // 20mm margin on each side
        const maxHeight = pageHeight - 60; // Space for title and margins
        
        // Calculate aspect ratio preserving dimensions
        const aspectRatio = canvas.width / canvas.height;
        let imgWidth = maxWidth;
        let imgHeight = maxWidth / aspectRatio;
        
        if (imgHeight > maxHeight) {
          imgHeight = maxHeight;
          imgWidth = maxHeight * aspectRatio;
        }
        
        const x = (pageWidth - imgWidth) / 2;
        const y = 45;
        
        // Convert canvas to high-quality image
        const imgData = canvas.toDataURL('image/png', 1.0);
        
        console.log('Adding image to PDF:', { 
          x: x.toFixed(2), 
          y: y.toFixed(2), 
          width: imgWidth.toFixed(2), 
          height: imgHeight.toFixed(2) 
        });
        
        pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);

        // Add data summary if requested
        if (options.includeData && options.snapshot) {
          pdf.addPage();
          this.addDataSummaryToPDF(pdf, options.snapshot);
        }

        // Save PDF
        const safeFilename = filename.replace(/[^a-zA-Z0-9-_]/g, '-');
        pdf.save(`${safeFilename}.pdf`);
        
        console.log('âœ… Enhanced PDF saved successfully!');
      } finally {
        restoreElement();
      }
    } catch (error) {
      console.error('Enhanced PDF export failed:', error);
      throw new Error(`Enhanced PDF export failed: ${(error as Error).message}`);
    }
  }

  /**
   * Simple and reliable PDF export method
   */
  async exportToPDFSimple(
    elementId: string,
    filename: string = 'haunted-mansion-report',
    options: { includeData?: boolean; snapshot?: MansionSnapshot } = {}
  ): Promise<void> {
    try {
      console.log('ðŸŽƒ Starting simple PDF export...', { elementId, filename });
      
      // Create PDF directly from data instead of trying to capture complex DOM
      const pdf = new jsPDF({
        orientation: 'landscape',
        unit: 'mm',
        format: 'a4'
      });

      // Add title with proper font handling
      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(24);
      pdf.setTextColor(255, 107, 53);
      pdf.text('Haunted AWS Cost Guard Report', 20, 25);

      // Add timestamp
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(12);
      pdf.setTextColor(100, 100, 100);
      const timestamp = new Date().toLocaleString('en-US', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
      pdf.text(`Generated: ${timestamp}`, 20, 35);

      // Add services data if available
      if (options.snapshot?.services && options.snapshot.services.length > 0) {
        let yPos = 55;
        
        // Add summary
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(16);
        pdf.setTextColor(255, 107, 53);
        pdf.text('Cost Summary', 20, yPos);
        yPos += 15;

        // Add total cost
        const totalCost = options.snapshot.services.reduce((sum, service) => sum + service.totalCost, 0);
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(14);
        pdf.setTextColor(0, 0, 0);
        pdf.text(`Total Cost: $${totalCost.toFixed(2)} USD`, 20, yPos);
        yPos += 10;
        pdf.text(`Services: ${options.snapshot.services.length}`, 20, yPos);
        yPos += 10;
        pdf.text(`Mode: ${options.snapshot.metadata.mode.toUpperCase()}`, 20, yPos);
        yPos += 20;

        // Add services list
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(14);
        pdf.setTextColor(255, 107, 53);
        pdf.text('Service Details', 20, yPos);
        yPos += 15;

        options.snapshot.services.forEach((service, index) => {
          if (yPos > 180) { // Start new page if needed
            pdf.addPage();
            yPos = 20;
          }
          
          // Service name
          pdf.setFont('helvetica', 'bold');
          pdf.setFontSize(12);
          pdf.setTextColor(0, 0, 0);
          pdf.text(`${index + 1}. ${service.displayName || service.service}`, 25, yPos);
          yPos += 8;
          
          // Service details
          pdf.setFont('helvetica', 'normal');
          pdf.setFontSize(10);
          pdf.setTextColor(60, 60, 60);
          pdf.text(`   Cost: $${service.totalCost.toFixed(2)} ${service.currency}`, 25, yPos);
          yPos += 6;
          
          const budgetUsage = (service.budgetUtilization * 100).toFixed(1);
          const budgetColor = service.budgetUtilization > 1 ? [255, 0, 0] : 
                             service.budgetUtilization > 0.8 ? [255, 165, 0] : [0, 128, 0];
          pdf.setTextColor(budgetColor[0], budgetColor[1], budgetColor[2]);
          pdf.text(`   Budget Usage: ${budgetUsage}%`, 25, yPos);
          yPos += 6;
          
          if (service.trend) {
            pdf.setTextColor(60, 60, 60);
            pdf.text(`   Trend: ${service.trend}`, 25, yPos);
            yPos += 6;
          }
          
          yPos += 5; // Extra spacing between services
        });
      } else {
        // No data available
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(14);
        pdf.setTextColor(100, 100, 100);
        pdf.text('No service data available. Please load data in Demo or AWS mode.', 20, 70);
      }

      // Add footer
      pdf.setFont('helvetica', 'italic');
      pdf.setFontSize(8);
      pdf.setTextColor(100, 100, 100);
      pdf.text('Generated by Haunted AWS Cost Guard', 20, pdf.internal.pageSize.getHeight() - 10);

      // Save PDF
      const safeFilename = filename.replace(/[^a-zA-Z0-9-_]/g, '-');
      pdf.save(`${safeFilename}.pdf`);
      
      console.log('âœ… Simple PDF saved successfully!');
    } catch (error) {
      console.error('Simple PDF export failed:', error);
      throw new Error(`Simple PDF export failed: ${(error as Error).message}`);
    }
  }

  /**
   * Alternative PDF export method using DOM-to-image approach
   */
  async exportToPDFAlternative(
    elementId: string,
    filename: string = 'haunted-mansion-report',
    options: { includeData?: boolean; snapshot?: MansionSnapshot } = {}
  ): Promise<void> {
    try {
      console.log('ðŸŽƒ Starting alternative PDF export...', { elementId, filename });
      
      const element = document.getElementById(elementId);
      if (!element) {
        throw new Error('Element not found');
      }

      // Create a simplified version for PDF
      const simplifiedElement = this.createSimplifiedMansionForPDF(element, options.snapshot);
      document.body.appendChild(simplifiedElement);

      try {
        // Wait for element to render
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Capture the simplified element
        const canvas = await html2canvas(simplifiedElement, {
          backgroundColor: '#1a1a2e',
          scale: 2,
          useCORS: true,
          allowTaint: true,
          logging: false,
          width: 800,
          height: 600
        });

        // Create PDF
        const pdf = new jsPDF({
          orientation: 'landscape',
          unit: 'mm',
          format: 'a4'
        });

        // Add title
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(20);
        pdf.setTextColor(255, 107, 53);
        pdf.text('ðŸ‘» Haunted AWS Cost Guard Report', 20, 20);

        // Add timestamp
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(12);
        pdf.setTextColor(100, 100, 100);
        const timestamp = new Date().toLocaleString();
        pdf.text(`Generated: ${timestamp}`, 20, 30);

        // Add image
        const imgData = canvas.toDataURL('image/png');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        
        const maxWidth = pageWidth - 40;
        const maxHeight = pageHeight - 80;
        
        let imgWidth = maxWidth;
        let imgHeight = (canvas.height * maxWidth) / canvas.width;
        
        if (imgHeight > maxHeight) {
          imgHeight = maxHeight;
          imgWidth = (canvas.width * maxHeight) / canvas.height;
        }
        
        const x = (pageWidth - imgWidth) / 2;
        const y = 40;
        
        pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);

        // Add data summary if requested
        if (options.includeData && options.snapshot) {
          pdf.addPage();
          this.addDataSummaryToPDF(pdf, options.snapshot);
        }

        // Save PDF
        const safeFilename = filename.replace(/[^a-zA-Z0-9-_]/g, '-');
        pdf.save(`${safeFilename}.pdf`);
        
        console.log('âœ… Alternative PDF saved successfully!');
      } finally {
        // Clean up
        document.body.removeChild(simplifiedElement);
      }
    } catch (error) {
      console.error('Alternative PDF export failed:', error);
      throw new Error(`Alternative PDF export failed: ${(error as Error).message}`);
    }
  }

  /**
   * Create a simplified mansion layout for PDF export
   */
  private createSimplifiedMansionForPDF(originalElement: HTMLElement, snapshot?: MansionSnapshot): HTMLElement {
    const container = document.createElement('div');
    container.style.cssText = `
      width: 800px;
      height: 600px;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      padding: 20px;
      color: white;
      font-family: Arial, sans-serif;
      position: absolute;
      top: -10000px;
      left: -10000px;
    `;

    // Add title
    const title = document.createElement('h1');
    title.textContent = 'ðŸ‘» Haunted AWS Cost Guard';
    title.style.cssText = `
      color: #fb923c;
      font-size: 24px;
      margin-bottom: 20px;
      text-align: center;
    `;
    container.appendChild(title);

    // Add services if available
    if (snapshot?.services) {
      const servicesContainer = document.createElement('div');
      servicesContainer.style.cssText = `
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        margin-top: 20px;
      `;

      snapshot.services.slice(0, 9).forEach((service) => {
        const serviceRoom = document.createElement('div');
        serviceRoom.style.cssText = `
          background: rgba(255, 107, 53, 0.2);
          border: 2px solid #fb923c;
          border-radius: 8px;
          padding: 15px;
          text-align: center;
          color: white;
        `;

        serviceRoom.innerHTML = `
          <h3 style="margin: 0 0 10px 0; font-size: 16px;">${service.displayName || service.service}</h3>
          <div style="color: #fb923c; font-weight: bold; font-size: 18px; margin: 10px 0;">
            $${service.totalCost.toFixed(2)}
          </div>
          <p style="margin: 0; font-size: 12px;">
            Budget: ${(service.budgetUtilization * 100).toFixed(1)}% used
          </p>
        `;

        servicesContainer.appendChild(serviceRoom);
      });

      container.appendChild(servicesContainer);
    }

    // Add footer
    const footer = document.createElement('div');
    footer.style.cssText = `
      position: absolute;
      bottom: 20px;
      left: 20px;
      right: 20px;
      text-align: center;
      font-size: 12px;
      color: #ccc;
    `;
    footer.textContent = `Generated: ${new Date().toLocaleString()}`;
    container.appendChild(footer);

    return container;
  }
  /**
   * Wait for element to settle (animations, loading, etc.)
   */
  private async waitForElementToSettle(element: HTMLElement): Promise<void> {
    return new Promise((resolve) => {
      // Wait for any pending animations or renders
      setTimeout(() => {
        // Additional check for Konva stages
        const konvaStages = element.querySelectorAll('canvas');
        if (konvaStages.length > 0) {
          // Give Konva stages extra time to render
          setTimeout(resolve, 500);
        } else {
          resolve();
        }
      }, 200);
    });
  }

  /**
   * Prepare element for PDF capture
   */
  private preparePDFElement(element: HTMLElement): () => void {
    const originalStyles = new Map<HTMLElement, string>();
    
    // Disable animations and transitions
    const allElements = element.querySelectorAll('*');
    allElements.forEach((el) => {
      const htmlEl = el as HTMLElement;
      originalStyles.set(htmlEl, htmlEl.style.cssText);
      
      // Disable animations for PDF capture
      htmlEl.style.animation = 'none';
      htmlEl.style.transition = 'none';
      htmlEl.style.transform = 'none';
    });
    
    // Add PDF-ready class
    element.classList.add('pdf-export-ready');
    
    // Return restore function
    return () => {
      element.classList.remove('pdf-export-ready');
      originalStyles.forEach((style, el) => {
        el.style.cssText = style;
      });
    };
  }

  /**
   * Prepare element for PDF capture with special Konva handling
   */
  private preparePDFElementForKonva(element: HTMLElement): () => void {
    const originalStyles = new Map<HTMLElement, string>();
    
    // Find all elements including Konva canvases
    const allElements = element.querySelectorAll('*');
    allElements.forEach((el) => {
      const htmlEl = el as HTMLElement;
      originalStyles.set(htmlEl, htmlEl.style.cssText);
      
      // Disable animations for PDF capture
      htmlEl.style.animation = 'none';
      htmlEl.style.transition = 'none';
      htmlEl.style.transform = 'none';
      
      // Special handling for canvas elements (Konva)
      if (htmlEl.tagName === 'CANVAS') {
        htmlEl.style.opacity = '1';
        htmlEl.style.visibility = 'visible';
        htmlEl.style.display = 'block';
        htmlEl.style.position = 'relative';
        htmlEl.style.zIndex = '1';
      }
    });
    
    // Add PDF-ready class
    element.classList.add('pdf-export-ready');
    
    // Return restore function
    return () => {
      element.classList.remove('pdf-export-ready');
      originalStyles.forEach((style, el) => {
        el.style.cssText = style;
      });
    };
  }

  /**
   * Robust PDF export with improved Konva canvas handling
   */
  async exportToPDF(
    elementId: string,
    filename: string = 'haunted-mansion-report',
    options: { includeData?: boolean; snapshot?: MansionSnapshot; useKoreanFallback?: boolean } = {}
  ): Promise<void> {
    try {
      console.log('ðŸŽƒ Starting PDF export...', { elementId, filename });
      
      // ìš”ì†Œ ê²€ì¦
      const validation = validateElementForPDF(elementId);
      if (!validation.isValid) {
        console.error('Element validation failed:', validation.error);
        console.log('Available elements with IDs:', Array.from(document.querySelectorAll('[id]')).map(el => el.id));
        throw new Error(validation.error || 'Element validation failed');
      }
      
      const element = validation.element!;
      console.log('Element validated:', {
        id: element.id,
        width: element.offsetWidth,
        height: element.offsetHeight,
        children: element.children.length,
        computedStyle: window.getComputedStyle(element).display
      });

      // Wait for any animations to settle and ensure element is fully rendered
      await this.waitForElementToSettle(element);

      // Prepare element for PDF capture with special Konva handling
      const restoreElement = this.preparePDFElementForKonva(element);
      
      let canvas: HTMLCanvasElement;
      try {
        // Create canvas with Konva-optimized settings
        console.log('ðŸ“¸ Creating canvas with Konva support...');
        canvas = await html2canvas(element, {
          backgroundColor: '#1a1a2e',
          scale: 2, // Higher scale for better quality
          useCORS: true,
          allowTaint: true, // Allow for Konva canvases
          logging: true, // Enable logging for debugging
          width: element.offsetWidth,
          height: element.offsetHeight,
          foreignObjectRendering: true, // Enable for better canvas rendering
          imageTimeout: 30000,
          removeContainer: false, // Keep container for Konva
          onclone: (clonedDoc, clonedElement) => {
            // Handle Konva canvases in the cloned document
            const konvaCanvases = clonedElement.querySelectorAll('canvas');
            console.log(`Found ${konvaCanvases.length} canvas elements in clone`);
            
            konvaCanvases.forEach((canvas, index) => {
              console.log(`Processing canvas ${index}:`, {
                width: canvas.width,
                height: canvas.height,
                style: canvas.style.cssText
              });
              
              // Ensure canvas is visible
              canvas.style.opacity = '1';
              canvas.style.visibility = 'visible';
              canvas.style.display = 'block';
            });
          }
        });
        
        console.log('Canvas created successfully:', { 
          width: canvas.width, 
          height: canvas.height,
          hasData: canvas.width > 0 && canvas.height > 0
        });

        if (canvas.width === 0 || canvas.height === 0) {
          throw new Error('Canvas capture failed - element may not be visible or properly rendered');
        }
      } finally {
        // Always restore element styles
        restoreElement();
      }

      // Create PDF with proper error handling
      console.log('ðŸ“„ Creating PDF...');
      const pdf = new jsPDF({
        orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
        unit: 'mm',
        format: 'a4'
      });

      try {
        // Add title
        pdf.setFont('helvetica', 'bold');
        pdf.setFontSize(20);
        pdf.setTextColor(255, 107, 53);
        pdf.text('ðŸ‘» Haunted AWS Cost Guard Report', 20, 20);

        // Add timestamp
        pdf.setFont('helvetica', 'normal');
        pdf.setFontSize(12);
        pdf.setTextColor(100, 100, 100);
        const timestamp = new Date().toLocaleString('en-US', {
          year: 'numeric',
          month: '2-digit',
          day: '2-digit',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
        pdf.text(`Generated: ${timestamp}`, 20, 30);

        // Convert canvas to image data
        const imgData = canvas.toDataURL('image/png', 0.95);
        console.log('Image data created, length:', imgData.length);

        // Calculate optimal image dimensions
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        
        const maxWidth = pageWidth - 40; // 20mm margin on each side
        const maxHeight = pageHeight - 80; // Space for title and margins
        
        let imgWidth = maxWidth;
        let imgHeight = (canvas.height * maxWidth) / canvas.width;
        
        if (imgHeight > maxHeight) {
          imgHeight = maxHeight;
          imgWidth = (canvas.width * maxHeight) / canvas.height;
        }
        
        const x = (pageWidth - imgWidth) / 2;
        const y = 40;
        
        console.log('Adding image to PDF:', { x, y, imgWidth, imgHeight });
        pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);

        // Add data summary if requested
        if (options.includeData && options.snapshot) {
          pdf.addPage();
          this.addDataSummaryToPDF(pdf, options.snapshot);
        }

        // Save PDF with safe filename
        const safeFilename = filename.replace(/[^a-zA-Z0-9-_]/g, '-');
        pdf.save(`${safeFilename}.pdf`);
        
        console.log('âœ… PDF saved successfully!');
      } catch (pdfError) {
        console.error('PDF creation failed:', pdfError);
        throw new Error(`PDF creation failed: ${(pdfError as Error).message}`);
      }
    } catch (error) {
      console.error('PDF export failed:', error);
      throw new Error(`PDF export failed: ${(error as Error).message}`);
    }
  }

  /**
   * Export mansion visual as PNG
   */
  async exportToPNG(
    elementId: string,
    filename: string = 'haunted-mansion'
  ): Promise<void> {
    try {
      const element = document.getElementById(elementId);
      if (!element) {
        throw new Error('Element not found');
      }

      const canvas = await html2canvas(element, {
        backgroundColor: '#1a1a2e',
        scale: 2,
        useCORS: true,
        allowTaint: true
      });

      canvas.toBlob((blob) => {
        if (blob) {
          saveAs(blob, `${filename}.png`);
        }
      });
    } catch (error) {
      console.error('PNG export failed:', error);
      throw new Error('PNG export failed');
    }
  }

  /**
   * Export data as JSON
   */
  exportToJSON(snapshot: MansionSnapshot, filename: string = 'mansion-data'): void {
    try {
      const dataStr = JSON.stringify(snapshot, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      saveAs(blob, `${filename}.json`);
    } catch (error) {
      console.error('JSON export failed:', error);
      throw new Error('JSON export failed');
    }
  }

  /**
   * Export cost data as CSV
   */
  exportToCSV(services: any[], filename: string = 'cost-data'): void {
    try {
      const headers = [
        'Service',
        'Display Name',
        'Total Cost',
        'Currency',
        'Budget Utilization (%)',
        'Trend'
      ];

      const rows = services.map(service => [
        service.service,
        service.displayName,
        service.totalCost,
        service.currency,
        (service.budgetUtilization * 100).toFixed(2),
        service.trend
      ]);

      const csvContent = [headers, ...rows]
        .map(row => row.map(field => `"${field}"`).join(','))
        .join('\n');

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      saveAs(blob, `${filename}.csv`);
    } catch (error) {
      console.error('CSV export failed:', error);
      throw new Error('CSV export failed');
    }
  }

  /**
   * Generate a snapshot of the current mansion state
   */
  generateMansionSnapshot(
    services: any[],
    viewSettings: any,
    budgets?: any[],
    mode: 'demo' | 'aws' = 'demo'
  ): MansionSnapshot {
    const totalCost = services.reduce((sum, service) => sum + service.totalCost, 0);
    
    return {
      timestamp: new Date(),
      services,
      viewSettings,
      budgets,
      metadata: {
        version: '1.0.0',
        mode,
        totalCost,
        currency: services[0]?.currency || 'USD'
      }
    };
  }

  /**
   * Add data summary to PDF
   */
  private addDataSummaryToPDF(pdf: jsPDF, snapshot: MansionSnapshot): void {
    // Add title
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(16);
    pdf.setTextColor(255, 107, 53);
    pdf.text('Cost Summary', 20, 20);

    // Add metadata
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(12);
    pdf.setTextColor(0, 0, 0);
    
    let yPos = 35;
    pdf.text(`Total Cost: ${snapshot.metadata.totalCost.toFixed(2)} ${snapshot.metadata.currency}`, 20, yPos);
    yPos += 8;
    pdf.text(`Mode: ${snapshot.metadata.mode.toUpperCase()}`, 20, yPos);
    yPos += 8;
    pdf.text(`Services: ${snapshot.services.length}`, 20, yPos);
    yPos += 15;

    // Add services list
    snapshot.services.forEach((service, index) => {
      if (yPos > 250) { // Start new page if needed
        pdf.addPage();
        yPos = 20;
      }
      
      pdf.setFont('helvetica', 'bold');
      pdf.text(`${index + 1}. ${service.displayName || service.service}`, 20, yPos);
      yPos += 6;
      
      pdf.setFont('helvetica', 'normal');
      pdf.text(`   Cost: ${service.totalCost.toFixed(2)} ${service.currency}`, 20, yPos);
      yPos += 6;
      
      pdf.text(`   Budget Usage: ${(service.budgetUtilization * 100).toFixed(1)}%`, 20, yPos);
      yPos += 10;
    });

    // Add footer
    pdf.setFont('helvetica', 'italic');
    pdf.setFontSize(8);
    pdf.setTextColor(100, 100, 100);
    pdf.text('Generated by Haunted AWS Cost Guard', 20, pdf.internal.pageSize.getHeight() - 10);
  }

  /**
   * Trigger browser print dialog
   */
  printMansion(): void {
    window.print();
  }
}

export const exportService = new ExportService();